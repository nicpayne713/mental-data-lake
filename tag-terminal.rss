<?xml version="1.0" encoding="utf-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Pype.dev</title><link>https://pype.dev</link><description>my mental data-lake</description><pubDate>Thu, 19 Dec 2024 05:59:30 GMT</pubDate><lastBuildDate>Sat, 25 Jan 2025 19:52:49 GMT</lastBuildDate><generator>marmite</generator><image><url>https://pype.dev/media/og-02.png</url><title></title><link></link></image><item><title>docker context (and an issue to question your sanity)</title><link>https://pype.dev/docker-context-and-an-issue-to-question-your-sanity.html</link><author>nicpayne</author><category>python</category><category>terminal</category><category>tech</category><guid>https://pype.dev/docker-context-and-an-issue-to-question-your-sanity.html</guid><pubDate>Thu, 19 Dec 2024 05:59:30 GMT</pubDate><source url="https://pype.dev">tag-terminal</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>docker contexts are great, would recommend putting them in your prompt though (via starship or something else)... here's why</p>
<p>I like to manage my containers remotely - I have a nice development setup on my desktop and I try to keep my server as bare-bones as possible. For a while I've been using ansible which makes it easy to manage configuration etc on other machines. But I recently learned about docker contexts and I'm planning to scale down my homelab management to just docker-compose stacks rather than a bunch of super complicated ansible playbooks</p>
<p>So, setting up a context is easy - it's basically an ssh connection to another machine!</p>
<p><code>docker context create koober --docker &quot;host=ssh://nic@koober&quot;</code></p>
<p><code>koober</code> is one of my dev machines and my <code>~/.ssh/config</code> is setup such that I can <code>ssh nic@koober</code>, this makes the context work really seamlessly.</p>
<p>So there's the <code>default</code> context (the machine you're on) and now I have <code>koober</code></p>
<p>To use it you run <code>docker context use koober</code></p>
<p>And then to check we can <code>ls</code> the contexts</p>
<pre><code>docker context ls
NAME       DESCRIPTION                               DOCKER ENDPOINT               ERROR
default    Current DOCKER_HOST based configuration   unix:///var/run/docker.sock   
koober *                                             ssh://nic@koober
</code></pre>
<blockquote>
<p>Notice the * - that indicates that's our current context.</p>
</blockquote>
<h2><a href="#trouble" aria-hidden="true" class="anchor" id="trouble"></a>Trouble</h2>
<p>Now here's where things get hairy... you've gotta be super-aware of what context you're using. I have an indicator in my starship prompt that shows the current context, but since I'm new to using them I kind of didn't notice it until I ran into this issue...</p>
<p>I'm working on a python application in docker but was not able to execute the entrypoint even though I KNEW the file was there... let's take a look</p>
<h3><a href="#example" aria-hidden="true" class="anchor" id="example"></a>Example</h3>
<p>Here's a minimal hello world applycation in docker to illustrate the issue</p>
<pre><code class="language-python"># main.py
print(&quot;hello world&quot;)
</code></pre>
<pre><code class="language-Dockerfile"># Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Run the main.py script as the container's main process
CMD [&quot;python&quot;, &quot;main.py&quot;]
</code></pre>
<pre><code class="language-yaml">services:
  hello-world:
    build: .
    volumes:
      - .:/app
</code></pre>
<p>Notice volume mounting in my project directory <code>.</code> to <code>/app</code> as a common practice to develop inside the container</p>
<p>Here's where I started to question my sanity...</p>
<pre><code class="language-bash">✗ docker compose up                                            
[+] Running 1/0
 ✔ Container docker-context-example-hello-world-1  Created                                                                                                                                                                                                                                                              0.0s 
Attaching to hello-world-1
hello-world-1  | python: can't open file '/app/main.py': [Errno 2] No such file or directory
hello-world-1 exited with code 2
</code></pre>
<p><code>python can't open file</code>? hmm... Let's take a look at the image</p>
<p>First let's make sure we get the image name right</p>
<pre><code class="language-bash">✗ docker container ls -a              
CONTAINER ID   IMAGE                                           COMMAND                  CREATED          STATUS                       PORTS                                                                                  NAMES
3d7285fc39e2   docker-context-example-hello-world              &quot;python main.py&quot;         10 minutes ago   Exited (2) 44 seconds ago                                                                                           docker-context-example-hello-world-1
</code></pre>
<p>Now we can <code>docker run --rm -it --entrypoint /bin/bash --name debug docker-context-example-hello-world</code></p>
<pre><code class="language-bash">❯ docker run --rm -it --entrypoint /bin/bash --name debug docker-context-example-hello-world  
root@ee46d0e22de8:/app# python main.py
Hello, World!
root@ee46d0e22de8:/app# 
</code></pre>
<p>WHAT THE HECK??</p>
<h2><a href="#what-happened" aria-hidden="true" class="anchor" id="what-happened"></a>What happened...</h2>
<p>What happened turns out to be pretty simple once we realize I'm using contexts...</p>
<p><code>koboer</code> is a remote context, the <code>docker run</code> and <code>docker compose up</code> commands are interacting with the docker socket on that machine.</p>
<p>So if I compose up the stack notice that there's a volume bind mount in there - well those do <em>not</em> work with contexts (or at least I'm not aware of hose to make it work) and so the <code>/app</code> directory was getting blown away essentially with an empty overlay...</p>
<p>But when running with just <code>docker run</code> with no volume mount, the code was copied in during the build and is right where we expect it...</p>
<h3><a href="#lets-prove-it" aria-hidden="true" class="anchor" id="lets-prove-it"></a>Let's prove it</h3>
<pre><code class="language-bash">❯ docker run --rm -it --entrypoint /bin/bash --name debug -v .:/app docker-context-example-hello-world
root@903f591c0384:/app# python main.py
python: can't open file '/app/main.py': [Errno 2] No such file or directory
root@903f591c0384:/app# 
</code></pre>
<pre><code>Adding a `-v .:/app` to match the compose file, we get the same error...
</code></pre>
<p>If we switch to the default context we are back up and running as expected</p>
<pre><code class="language-bash">✗ docker context use default
default
Current context is now &quot;default&quot;

nic in /tmp/docker-context-example  via   v3.13.0  (dev) 󰒄 󱔎 NO PYTHON ENVIORNMENT SET 
❯ docker compose up         
[+] Running 1/0
 ✔ Container docker-context-example-hello-world-1  Created                                                                                                                                                                                                                                                              0.0s 
Attaching to hello-world-1
hello-world-1  | Hello, World!
hello-world-1 exited with code 0

nic in /tmp/docker-context-example  via   v3.13.0  (dev) 󰒄 󱔎 NO PYTHON ENVIORNMENT SET 
❯ docker run --rm -it --entrypoint /bin/bash --name debug -v .:/app docker-context-example-hello-world
root@4045b6aa8883:/app# python main.py
Hello, World!
root@4045b6aa8883:/app# 
</code></pre>
<p>Successful runs on both accounts with the volume mount</p>
<h2><a href="#tldr" aria-hidden="true" class="anchor" id="tldr"></a>TLDR</h2>
<p>Context is king</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>rsync like a pro</title><link>https://pype.dev/rsync-like-a-pro.html</link><author>nicpayne</author><category>linux</category><category>terminal</category><category>tech</category><guid>https://pype.dev/rsync-like-a-pro.html</guid><pubDate>Wed, 11 Dec 2024 10:52:23 GMT</pubDate><source url="https://pype.dev">tag-terminal</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>I am moving a hefty amount of data to a new ZFS pool due to some corruption and I want to avoid using <code>zfs send/recv</code> for this just to make sure I don't propagate any corrupted data to my new pool.</p>
<p>I've used <code>rsync</code> for simple things before but I needed this to be a little smarter and I wanted to see simple progress without flooding my terminal with a billion filenames.</p>
<h2><a href="#tldr" aria-hidden="true" class="anchor" id="tldr"></a>TLDR</h2>
<p>TLDR:
<code>rsync -aHAX --chmod=Da+s --info=progress2 --inplace --exclude='encrypted/docker/frigate-media' /tank/ /harbor/</code></p>
<h2><a href="#explanation" aria-hidden="true" class="anchor" id="explanation"></a>Explanation</h2>
<p>-aHAX: Preserves attributes (archive mode, hard links, ACLs, extended attributes).
--chmod=Da+s: Ensures the setgid bit is applied to directories.
--info=progress2: Provides detailed progress information, including overall data transfer stats.
--inplace: Writes directly to the destination file, avoiding temporary files (useful for large files).
--exclude='encrypted/docker/frigate-media': Excludes the specified path (relative to the /tank root).
/tank/ /harbor/: Ensures the contents of /tank are copied directly into /harbor.</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>hostnamectl to easily change hostname</title><link>https://pype.dev/hostnamectl-to-easily-change-hostname.html</link><author>nicpayne</author><category>linux</category><category>terminal</category><category>tech</category><guid>https://pype.dev/hostnamectl-to-easily-change-hostname.html</guid><pubDate>Fri, 06 Dec 2024 07:25:59 GMT</pubDate><source url="https://pype.dev">tag-terminal</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>hostnamectl is apparently a linux utility for easily changing your hostname in a variety of ways</p>
<pre><code class="language-bash">
❯ hostnamectl --help
hostnamectl [OPTIONS...] COMMAND ...

Query or change system hostname.

Commands:
  status                 Show current hostname settings
  hostname [NAME]        Get/set system hostname
  icon-name [NAME]       Get/set icon name for host
  chassis [NAME]         Get/set chassis type for host
  deployment [NAME]      Get/set deployment environment for host
  location [NAME]        Get/set location for host

Options:
  -h --help              Show this help
     --version           Show package version
     --no-ask-password   Do not prompt for password
  -H --host=[USER@]HOST  Operate on remote host
  -M --machine=CONTAINER Operate on local container
     --transient         Only set transient hostname
     --static            Only set static hostname
     --pretty            Only set pretty hostname
     --json=pretty|short|off
                         Generate JSON output

See the hostnamectl(1) man page for details.
</code></pre>
<p>I learned there's transient and static hostnames, so that's cool...</p>
<p>The thing I needed was <code>hostnamectl --static hostname babyblue-aurora</code></p>
<p>pretty sweet tool</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Restart KDE Plasma</title><link>https://pype.dev/restart-kde-plasma.html</link><author>nicpayne</author><category>linux</category><category>terminal</category><category>tech</category><guid>https://pype.dev/restart-kde-plasma.html</guid><pubDate>Fri, 08 Nov 2024 15:53:52 GMT</pubDate><source url="https://pype.dev">tag-terminal</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>Plasma shits the bed a little too often on Fedora for me right now but I finally have a quick fix...</p>
<pre><code>
sudo killall plasmashell

kstart plasmashell

</code></pre>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item><item><title>Fonts in VS C**e</title><link>https://pype.dev/fonts-in-vs-c-e.html</link><author>nicpayne</author><category>linux</category><category>terminal</category><category>tech</category><guid>https://pype.dev/fonts-in-vs-c-e.html</guid><pubDate>Mon, 20 May 2024 06:44:07 GMT</pubDate><source url="https://pype.dev">tag-terminal</source><content:encoded><![CDATA[<!-- Content Injected to every content markdown header -->
<p>Jet Brains has to be specified 'JetBrainsMono Nerd Font Mono'</p>
<!-- Content Injected to every content markdown footer -->
]]></content:encoded></item></channel></rss>